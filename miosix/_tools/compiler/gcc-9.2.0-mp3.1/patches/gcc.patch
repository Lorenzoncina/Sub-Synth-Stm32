diff -ruN gcc-9.2.0-old/config/gthr.m4 gcc-9.2.0/config/gthr.m4
--- gcc-9.2.0-old/config/gthr.m4	2012-10-15 15:10:30.000000000 +0200
+++ gcc-9.2.0/config/gthr.m4	2020-07-18 19:02:13.417006200 +0200
@@ -14,6 +14,7 @@
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
+    miosix)	thread_header=config/gthr-miosix.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
     posix)	thread_header=gthr-posix.h ;;
     rtems)	thread_header=config/gthr-rtems.h ;;
diff -ruN gcc-9.2.0-old/gcc/config/arm/arm.c gcc-9.2.0/gcc/config/arm/arm.c
--- gcc-9.2.0-old/gcc/config/arm/arm.c	2019-04-23 12:03:41.000000000 +0200
+++ gcc-9.2.0/gcc/config/arm/arm.c	2020-07-18 19:02:13.429006184 +0200
@@ -70,10 +70,20 @@
 #include "gimplify.h"
 #include "gimple.h"
 #include "selftest.h"
+#include "print-tree.h"
+#include <assert.h>
 
 /* This file should be included last.  */
 #include "target-def.h"
 
+/*
+ * https://gcc.gnu.org/legacy-ml/gcc/2017-05/msg00073.html
+ * Disable this warning at the compiler level, as Miosix skipped from GCC 4.7.3
+ * to GCC 9.2.0, so there's no affected code around.
+ */
+#undef warn_psabi /* in case it's already a macro */
+#define warn_psabi 0
+
 /* Forward definitions of types.  */
 typedef struct minipool_node    Mnode;
 typedef struct minipool_fixup   Mfix;
@@ -2758,8 +2768,30 @@
 	}
   }
 
-  if (TARGET_AAPCS_BASED)
-    synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
+  //Rationale:
+  //Compiling code that instantiates C++ static objects on architectures that do
+  //not have memory fence/barrier instructions (e.g: ARM7TDMI) causes undefined
+  //reference to `__sync_synchronize'.
+  //expand_mem_thread_fence() in gcc/optabs.c:6489 tries to emit ASM insn
+  //and failing that, emits the __sync_synchronize call if available.
+  //Synchronize_libfunc is used only in optabs.c and defined only for ARM/MIPS
+  //$ grep -R 'synchronize_libfunc' gcc-9.2.0
+  //libfuncs.h:79:#define synchronize_libfunc    (libfunc_table[LTI_synchronize])
+  //config/arm/arm.c:2776:    synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
+  //config/mips/mips.c:13535:      synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
+  //optabs.c:6500:  else if (synchronize_libfunc != NULL_RTX)
+  //optabs.c:6501:    emit_library_call (synchronize_libfunc, LCT_NORMAL, VOIDmode);
+  //$ grep -Rn 'LTI_synchronize' gcc-9.2.0
+  //libfuncs.h:29:  LTI_synchronize,
+  //libfuncs.h:79:#define synchronize_libfunc (libfunc_table[LTI_synchronize])
+  //The ARM implementation is in libgcc and only exists for linux and bsd.
+  //
+  //Solution: remove given ARM7TDMI don't need hardware memory barriers at all.
+  //
+  //When updating patches to new compiler, check that cortex-M targets have
+  //dmb instructions, while ARM7TDMI code has no calls to __sync_synchronize.
+  //if (TARGET_AAPCS_BASED)
+  //  synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
 
   speculation_barrier_libfunc = init_one_libfunc ("__speculation_barrier");
 }
@@ -7501,6 +7533,157 @@
     }
 }
 
+//TODO: #ifdef _MIOSIX does not work in this context
+
+//Taken from varasm.c, it is static unfortunately, hence the copy-paste
+static int
+contains_pointers_p (const_tree type)
+{
+  switch (TREE_CODE (type))
+    {
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+      /* I'm not sure whether OFFSET_TYPE needs this treatment,
+	 so I'll play safe and return 1.  */
+    case OFFSET_TYPE:
+      return 1;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      {
+	tree fields;
+	/* For a type that has fields, see if the fields have pointers.  */
+	for (fields = TYPE_FIELDS (type); fields; fields = DECL_CHAIN (fields))
+	  if (TREE_CODE (fields) == FIELD_DECL
+	      && contains_pointers_p (TREE_TYPE (fields)))
+	    return 1;
+	return 0;
+      }
+
+    case ARRAY_TYPE:
+      /* An array type contains pointers if its element type does.  */
+      return contains_pointers_p (TREE_TYPE (type));
+
+    default:
+      return 0;
+    }
+}
+
+/*
+ * Miosix processes do not live in a virtual address space.
+ * Their code and constants (.text and .rodata) live in FLASH at an address
+ * that is not known until runtime, so PC-relative addressing must be used.
+ * Their variables (.data and .bss) live in RAM, and the offset between
+ * .text and RAM is not constant, so the GOT must be used with single-pic-base.
+ * This function takes a memory reference and returns true if PC-relative
+ * addressing must be used, or false if the GOT must be used.
+ */
+static bool miosix_processes_ref_demux(rtx orig)
+{
+    // This logic has been kept from the original code in legitimize_pic_address
+    if(GET_CODE(orig) == LABEL_REF) return true;
+    
+    // From here on we handle the SYMBOL_REF case
+    //TODO: we don't do anything for DECL_WEAK
+
+    // Dump data structures for debugging purpose
+    // print-rtl.c and print-tree.c are very useful for knowing how they work
+    //debug_rtx(orig);
+    //if(SYMBOL_REF_DECL(orig)) debug_tree(SYMBOL_REF_DECL(orig));
+    
+    bool result = false;
+    const_tree decl = SYMBOL_REF_DECL(orig);
+    if(decl)
+    {
+        if(TREE_CODE(decl) == FUNCTION_DECL)
+        {
+            /*
+             * Taking function address, testcase (compile with -O2)
+             * void f();
+             * typedef void (*fp)();
+             * fp get() { return &f; }
+             */
+            result = true;
+            //printf("constant (FUNCTION_DECL)\n\n");
+        } else if(TREE_CODE(decl) == VAR_DECL) {
+            const_tree type = TREE_TYPE(decl);
+            assert(type != NULL && "Miosix: SYMBOL_REF of unknown constness (type==0)");
+            if(contains_pointers_p(type))
+            {
+                /*
+                 * A true constant pointer can't exist in Miosix processes.
+                 * If it's a constant, the pointer would need to be
+                 * initialized at the definition site, and since it may
+                 * point to a variable in RAM, a runtime relocation is
+                 * needed to initialize it, and because of that it can't
+                 * stay in .rodata among the true constants.
+                 * Const pointers without relocations may exist, say for
+                 * instance int *const p=0; and those *could* stay in .rodata
+                 * but that creates another problem: how do we know from
+                 * the declaration only (extern int *const p;) whether the
+                 * pointer is in .rodata or not? We can't and thus we don't
+                 * know whether to use pc-relative or GOT addressing, so
+                 * we treat *all* const pointers as non const.
+                 */
+                //printf("variable (contains pointers)\n\n");
+            } else if(decl_readonly_section(decl,0)) {
+                /*
+                 * Non-extern consts in non optimized code, testcase (compile with -O0)
+                 * const char str[]="Hello world\n";
+                 * const char *get() { return str; }
+                 */
+                result = true;
+                //printf("constant (decl_readonly_section)\n\n");
+                // remaining if are because decl_readonly_section misses some
+                // const cases
+            } else if(TYPE_READONLY(type)) {
+                /*
+                 * Extern const, testcase (compile with -O2)
+                 * extern const int aRodata;
+                 * int get() { return aRodata; }
+                 */
+                result = true;
+                //printf("constant (TYPE_READONLY)\n\n");
+            } else {
+                /*
+                 * Variables, testcase (compile with -O2)
+                 * extern int aData;
+                 * int get() { return aData; }
+                 */
+                //printf("variable (decl!=0)\n\n");
+            }
+        } else assert(0 && "Miosix: SYMBOL_REF of unknown constness (TREE_CODE?)");
+    } else {
+        //we fall here when optimizations are enabled and sometimes decl==NULL
+        
+        //NOTE: SYMBOL_REF_BLOCK() is valid only if SYMBOL_REF_HAS_BLOCK_INFO_P()
+        if(!SYMBOL_REF_HAS_BLOCK_INFO_P(orig) || SYMBOL_REF_BLOCK(orig) == NULL)
+            assert(0 && "Miosix: SYMBOL_REF of unknown constness (decl==0)");
+        
+        //TODO: output.h defines a few default sections as global variables
+        //do we need to handle more than readonly_data_section?
+        if(SYMBOL_REF_BLOCK(orig)->sect == readonly_data_section)
+        {
+            /*
+             * Non-folded constants when optimizing, testcase (compile with -O2)
+             * const int aRodata2=42;
+             * const int *get() { return &aRodata2; }
+             */
+            result = true;
+            //printf("constant (sect==readonly)\n\n");
+        } else {
+            /* Defined (not just declared) vars when optimizing, testcase (compile with -O2)
+             * int aData=1;
+             * int get() { return aData; }
+             */
+            //printf("variable (decl==0)\n\n");
+        }
+    }
+
+    return result;
+}
+
 /* Legitimize PIC load to ORIG into REG.  If REG is NULL, a new pseudo is
    created to hold the result of the load.  If not NULL, PIC_REG indicates
    which register to use as PIC register, otherwise it is decided by register
@@ -7526,6 +7709,8 @@
 	  reg = gen_reg_rtx (Pmode);
 	}
 
+    bool miosix_ref_demux = miosix_processes_ref_demux(orig);
+
       /* VxWorks does not impose a fixed gap between segments; the run-time
 	 gap can be different from the object-file gap.  We therefore can't
 	 use GOTOFF unless we are absolutely sure that the symbol is in the
@@ -7535,13 +7720,7 @@
       /* References to weak symbols cannot be resolved locally: they
 	 may be overridden by a non-weak definition at link time.  */
       rtx_insn *insn;
-      if ((GET_CODE (orig) == LABEL_REF
-	   || (GET_CODE (orig) == SYMBOL_REF
-	       && SYMBOL_REF_LOCAL_P (orig)
-	       && (SYMBOL_REF_DECL (orig)
-		   ? !DECL_WEAK (SYMBOL_REF_DECL (orig)) : 1)))
-	  && NEED_GOT_RELOC
-	  && arm_pic_data_is_text_relative)
+    if (miosix_ref_demux && NEED_GOT_RELOC && arm_pic_data_is_text_relative)
 	insn = arm_pic_static_addr (orig, reg);
       else
 	{
@@ -23064,14 +23243,24 @@
 	  /* References to weak symbols cannot be resolved locally:
 	     they may be overridden by a non-weak definition at link
 	     time.  */
-	  if (!arm_pic_data_is_text_relative
-	      || (GET_CODE (x) == SYMBOL_REF
-		  && (!SYMBOL_REF_LOCAL_P (x)
-		      || (SYMBOL_REF_DECL (x)
-			  ? DECL_WEAK (SYMBOL_REF_DECL (x)) : 0))))
+      
+      /*
+       * NOTE: On Miosix processes GOTOFF can't work, as we don't know at
+       * time the offset between .text and .got/.data/whatever is in RAM
+       * so always use GOT.
+       * Without this patch a process with something as simple as
+       * int *ptr = { 0 };
+       * int *get() { return ptr; }
+       * uses GOTOFF and produces segfaults upon calling get()
+       */
+// 	  if (!arm_pic_data_is_text_relative
+// 	      || (GET_CODE (x) == SYMBOL_REF
+// 		  && (!SYMBOL_REF_LOCAL_P (x)
+// 		      || (SYMBOL_REF_DECL (x)
+// 			  ? DECL_WEAK (SYMBOL_REF_DECL (x)) : 0))))
 	    fputs ("(GOT)", asm_out_file);
-	  else
-	    fputs ("(GOTOFF)", asm_out_file);
+// 	  else
+// 	    fputs ("(GOTOFF)", asm_out_file);
 	}
       fputc ('\n', asm_out_file);
       return true;
diff -ruN gcc-9.2.0-old/gcc/config/arm/arm.h gcc-9.2.0/gcc/config/arm/arm.h
--- gcc-9.2.0-old/gcc/config/arm/arm.h	2019-04-23 12:03:41.000000000 +0200
+++ gcc-9.2.0/gcc/config/arm/arm.h	2020-07-18 19:02:13.469006131 +0200
@@ -878,7 +878,12 @@
 #define EH_RETURN_STACKADJ_RTX	gen_rtx_REG (SImode, ARM_EH_STACKADJ_REGNUM)
 
 #ifndef ARM_TARGET2_DWARF_FORMAT
-#define ARM_TARGET2_DWARF_FORMAT DW_EH_PE_pcrel
+//TODO: #ifdef _MIOSIX does not work in this context
+//Produce exception unwinding tables that work with Miosix processes
+//see processes-patch.md, section "The problem with unwinding exception tables"
+//we want pcrel as usual for the Miosix kernel, and datarel for processes (pic)
+#define ARM_TARGET2_DWARF_FORMAT (flag_pic ? DW_EH_PE_datarel : DW_EH_PE_pcrel)
+//#define ARM_TARGET2_DWARF_FORMAT DW_EH_PE_pcrel
 #endif
 
 /* ttype entries (the only interesting data references used)
diff -ruN gcc-9.2.0-old/gcc/config/arm/miosix-eabi.h gcc-9.2.0/gcc/config/arm/miosix-eabi.h
--- gcc-9.2.0-old/gcc/config/arm/miosix-eabi.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-9.2.0/gcc/config/arm/miosix-eabi.h	2020-07-18 19:02:13.469006131 +0200
@@ -0,0 +1,19 @@
+
+/*
+ * RATIONALE: adding builtin_define to always define _MIOSIX
+ * - when libgcc/libstdc++/newlib are compiled, as there are some #ifdef _MIOSIX
+ * - when Miosix processes are compiled, to allow #ifdef _MIOSIX
+ * Also add versioning to miosix-specific compiler patches.
+ * Note: intentionally breaking compatibility with previous compiler patches
+ * which defined _MIOSIX_GCC_PATCH_VERSION instead of _MIOSIX_GCC_PATCH_MAJOR
+ */
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()         \
+    do {                                 \
+        TARGET_BPABI_CPP_BUILTINS();     \
+        builtin_define("_MIOSIX");       \
+        builtin_define("_MIOSIX_GCC_PATCH_MAJOR=3"); \
+        builtin_define("_MIOSIX_GCC_PATCH_MINOR=1"); \
+        builtin_assert("system=miosix"); \
+    } while(false)
diff -ruN gcc-9.2.0-old/gcc/config/arm/t-arm-miosix gcc-9.2.0/gcc/config/arm/t-arm-miosix
--- gcc-9.2.0-old/gcc/config/arm/t-arm-miosix	1970-01-01 01:00:00.000000000 +0100
+++ gcc-9.2.0/gcc/config/arm/t-arm-miosix	2020-07-18 19:02:13.469006131 +0200
@@ -0,0 +1,49 @@
+
+## RATIONALE: build multilibs for ARM, Cortex-Mx, and the pie versions
+
+## To update this file, first have a look in t-arm-elf to see if some new
+## variable has been added
+## According to https://gcc.gnu.org/onlinedocs/gccint/Target-Fragment.html
+## MULTILIB_REQUIRED has been introduced replacing the awkwardly long
+## MULTILIB_EXCEPTIONS list.
+
+MULTILIB_OPTIONS     =
+MULTILIB_DIRNAMES    =
+MULTILIB_MATCHES     =
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_REQUIRED    =
+MULTILIB_REUSE       =
+
+MULTILIB_OPTIONS    += mthumb
+MULTILIB_DIRNAMES   += thumb
+
+MULTILIB_OPTIONS    += mcpu=cortex-m0/mcpu=cortex-m3/mcpu=cortex-m4/mcpu=cortex-m7
+MULTILIB_DIRNAMES   += cm0 cm3 cm4 cm7
+
+MULTILIB_OPTIONS    += mfloat-abi=hard
+MULTILIB_DIRNAMES   += hardfp
+
+MULTILIB_OPTIONS    += mfpu=fpv4-sp-d16/mfpu=fpv5-d16
+MULTILIB_DIRNAMES   += fpv4sp fpv5
+
+MULTILIB_OPTIONS    += fpie msingle-pic-base
+MULTILIB_DIRNAMES   += pie single-pic-base
+
+## The following multilibs will be built:
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m0
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m3
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m4/mfloat-abi=hard/mfpu=fpv4-sp-d16
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7/mfloat-abi=hard/mfpu=fpv5-d16
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m3/fpie/msingle-pic-base
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m4/mfloat-abi=hard/mfpu=fpv4-sp-d16/fpie/msingle-pic-base
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7/mfloat-abi=hard/mfpu=fpv5-d16/fpie/msingle-pic-base
+
+# The output produced by 'arm-miosix-eabi-gcc --print-multi-lib' is
+# .;
+# thumb/cm0;@mthumb@mcpu=cortex-m0
+# thumb/cm3;@mthumb@mcpu=cortex-m3
+# thumb/cm3/pie/single-pic-base;@mthumb@mcpu=cortex-m3@fpie@msingle-pic-base
+# thumb/cm4/hardfp/fpv4sp;@mthumb@mcpu=cortex-m4@mfloat-abi=hard@mfpu=fpv4-sp-d16
+# thumb/cm4/hardfp/fpv4sp/pie/single-pic-base;@mthumb@mcpu=cortex-m4@mfloat-abi=hard@mfpu=fpv4-sp-d16@fpie@msingle-pic-base
+# thumb/cm7/hardfp/fpv5;@mthumb@mcpu=cortex-m7@mfloat-abi=hard@mfpu=fpv5-d16
+# thumb/cm7/hardfp/fpv5/pie/single-pic-base;@mthumb@mcpu=cortex-m7@mfloat-abi=hard@mfpu=fpv5-d16@fpie@msingle-pic-base
diff -ruN gcc-9.2.0-old/gcc/config.gcc gcc-9.2.0/gcc/config.gcc
--- gcc-9.2.0-old/gcc/config.gcc	2019-08-03 22:16:22.000000000 +0200
+++ gcc-9.2.0/gcc/config.gcc	2020-07-18 19:02:13.469006131 +0200
@@ -1218,6 +1218,13 @@
 	tmake_file="${tmake_file} arm/t-arm arm/t-arm-elf"
 	target_cpu_cname="arm7tdmi"
 	case ${target} in
+	arm*-miosix-eabi*)
+	  # Copy options from arm*-*-eabi*, add the miosix-specific ones
+	  # and make sure arm/t-arm-elf is not added to tmake_file
+	  tm_file="${tm_file} newlib-stdint.h arm/miosix-eabi.h"  # Append
+	  tmake_file="arm/t-arm arm/t-arm-miosix arm/t-bpabi"     # Replace
+	  use_gcc_stdint=wrap
+	  ;;
 	arm*-*-eabi*)
 	  tm_file="$tm_file newlib-stdint.h"
 	  tmake_file="${tmake_file} arm/t-bpabi"
diff -ruN gcc-9.2.0-old/gcc/configure gcc-9.2.0/gcc/configure
--- gcc-9.2.0-old/gcc/configure	2019-06-26 11:15:46.000000000 +0200
+++ gcc-9.2.0/gcc/configure	2020-07-18 19:02:13.481006115 +0200
@@ -11860,7 +11860,7 @@
     # default
     target_thread_file='single'
     ;;
-  aix | dce | lynx | mipssde | posix | rtems | \
+  aix | dce | lynx | miosix | mipssde | posix | rtems | \
   single | tpf | vxworks | win32)
     target_thread_file=${enable_threads}
     ;;
diff -ruN gcc-9.2.0-old/gcc/configure.ac gcc-9.2.0/gcc/configure.ac
--- gcc-9.2.0-old/gcc/configure.ac	2019-06-26 11:15:46.000000000 +0200
+++ gcc-9.2.0/gcc/configure.ac	2020-07-18 19:02:13.481006115 +0200
@@ -1646,7 +1646,7 @@
     # default
     target_thread_file='single'
     ;;
-  aix | dce | lynx | mipssde | posix | rtems | \
+  aix | dce | lynx | miosix | mipssde | posix | rtems | \
   single | tpf | vxworks | win32)
     target_thread_file=${enable_threads}
     ;;
diff -ruN gcc-9.2.0-old/gcc/except.c gcc-9.2.0/gcc/except.c
--- gcc-9.2.0-old/gcc/except.c	2019-03-11 14:58:44.000000000 +0100
+++ gcc-9.2.0/gcc/except.c	2020-07-19 15:17:04.439702237 +0200
@@ -3022,6 +3022,11 @@
   else
     {
       tt_format = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/1);
+      // This is here for debugging the change to ARM_TARGET2_DWARF_FORMAT
+      // in Miosix processes: when compiling C++ code that throws and catches
+      // exceptions, it should print 0x10 (DW_EH_PE_pcrel) when compiling the
+      // kernel (non-pic) and 0x30 (DW_EH_PE_datarel) when compiling processes
+      //printf("\n\n-- called 0x%x --\n\n",tt_format);
       if (HAVE_AS_LEB128)
 	ASM_GENERATE_INTERNAL_LABEL (ttype_label,
 				     section ? "LLSDATTC" : "LLSDATT",
diff -ruN gcc-9.2.0-old/libatomic/config/miosix/host-config.h gcc-9.2.0/libatomic/config/miosix/host-config.h
--- gcc-9.2.0-old/libatomic/config/miosix/host-config.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-9.2.0/libatomic/config/miosix/host-config.h	2020-07-18 19:02:13.485006110 +0200
@@ -0,0 +1,23 @@
+
+/*
+ * According to libatomic_i.h, here we should implement
+ * - UWORD protect_start(void *ptr);
+ * - void protect_end(void *ptr, UWORD token);
+ * which are used by fop_n.c fop_n.c cas_n.c exch_n.c tas_n.c store_n.c for
+ * 'small' operations.
+ */
+
+unsigned int libat_quick_lock_n(void *ptr);
+void libat_quick_unlock_n(void *ptr, unsigned int token);
+
+static inline UWORD protect_start(void *ptr)
+{
+	return libat_quick_lock_n(ptr);
+}
+
+static inline void protect_end(void *ptr, UWORD token)
+{
+	libat_quick_unlock_n(ptr, token);
+}
+
+#include_next <host-config.h>
diff -ruN gcc-9.2.0-old/libatomic/config/miosix/lock.c gcc-9.2.0/libatomic/config/miosix/lock.c
--- gcc-9.2.0-old/libatomic/config/miosix/lock.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-9.2.0/libatomic/config/miosix/lock.c	2020-07-18 19:02:13.485006110 +0200
@@ -0,0 +1,13 @@
+
+/*
+ * According to libatomic_i.h, here we should implement
+ * - void libat_lock_n(void *ptr, size_t n);
+ * - void libat_unlock_n(void *ptr, size_t n);
+ * which are used by gexch.c gcas.c gload.c gstore.c for 'large' operations.
+ *
+ * Except, we don't. These function may be directly implemented in Miosix should
+ * the need arise, or intentionally left as undefined references if large
+ * locking intrinsics are to be disallowed.
+ */
+
+#include "libatomic_i.h"
diff -ruN gcc-9.2.0-old/libatomic/configure.tgt gcc-9.2.0/libatomic/configure.tgt
--- gcc-9.2.0-old/libatomic/configure.tgt	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libatomic/configure.tgt	2020-07-18 19:02:13.485006110 +0200
@@ -154,6 +154,10 @@
         esac
 	;;
 
+  arm*-miosix-eabi*)
+	config_path="miosix"
+	;;
+
   *-*-rtems*)
 	XCFLAGS="${configure_tgt_pre_target_cpu_XCFLAGS}"
 	config_path="rtems"
diff -ruN gcc-9.2.0-old/libgcc/config/arm/pr-support.c gcc-9.2.0/libgcc/config/arm/pr-support.c
--- gcc-9.2.0-old/libgcc/config/arm/pr-support.c	2019-04-23 12:03:41.000000000 +0200
+++ gcc-9.2.0/libgcc/config/arm/pr-support.c	2020-07-18 19:02:13.485006110 +0200
@@ -376,7 +376,14 @@
 _Unwind_Ptr
 _Unwind_GetDataRelBase (_Unwind_Context *context __attribute__ ((unused)))
 {
-  abort ();
+//TODO: #ifdef _MIOSIX does not work in this context
+//Support exception unwinding that work with Miosix processes
+//see processes-patch.md, section "The problem with unwinding exception tables"
+//NOTE: this code gets linked (even though it never gets used) also in the kernel,
+//so the symbol name we coose here must also exist in the kernel linker scripts
+  extern char _data asm("_data"); //defined in the linker script
+  return &_data;
+//   abort ();
 }
 
 _Unwind_Ptr
diff -ruN gcc-9.2.0-old/libgcc/config/arm/unwind-arm.h gcc-9.2.0/libgcc/config/arm/unwind-arm.h
--- gcc-9.2.0-old/libgcc/config/arm/unwind-arm.h	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libgcc/config/arm/unwind-arm.h	2020-07-19 15:18:14.643454187 +0200
@@ -57,6 +57,12 @@
 #elif defined(__symbian__) || defined(__uClinux__)
 #define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_absptr)
       /* Absolute pointer.  Nothing more to do.  */
+#elif defined(_MIOSIX)
+     //DO NOT DEFINE _GLIBCXX_OVERRIDE_TTYPE_ENCODING, we don't want that kludge
+     //as the encoding could be either pc-relative (kernel) or data-relative (processes)
+     //see processes-patch.md
+     //This relies on base_of_encoded_value() setting base to 0 for DW_EH_PE_pcrel
+     tmp += base ? base : ptr;
 #else
 #define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_pcrel)
       /* Pc-relative pointer.  */
diff -ruN gcc-9.2.0-old/libgcc/config/gthr-miosix.h gcc-9.2.0/libgcc/config/gthr-miosix.h
--- gcc-9.2.0-old/libgcc/config/gthr-miosix.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-9.2.0/libgcc/config/gthr-miosix.h	2020-07-18 19:02:13.485006110 +0200
@@ -0,0 +1,94 @@
+
+// RATIONALE: make the code generated by GCC thread safe by providing a thread model
+
+#ifndef GCC_GHTR_MIOSIX_H
+#define GCC_GHTR_MIOSIX_H
+
+#include <pthread.h>
+#include <unistd.h>
+#include <sched.h>
+#include <time.h>
+
+//Note to self: gthr.h contains useful information
+//on how a gthr-xxx.h should look like
+
+#define __GTHREADS 1
+#define __GTHREAD_HAS_COND 1
+#define __GTHREADS_CXX0X 1
+//Found in libstdc++
+#define _GTHREAD_USE_MUTEX_TIMEDLOCK 1
+
+//In Miosix, threads are always enabled, period.
+#define __gthread_active_p() 1
+
+typedef pthread_t       __gthread_t;
+typedef pthread_key_t   __gthread_key_t; //This actually is unimplemented
+typedef pthread_once_t  __gthread_once_t;
+typedef pthread_mutex_t __gthread_mutex_t;
+typedef pthread_mutex_t __gthread_recursive_mutex_t;
+typedef pthread_cond_t  __gthread_cond_t;
+typedef struct timespec __gthread_time_t;
+
+#define __GTHREAD_ONCE_INIT                     PTHREAD_ONCE_INIT
+#define __GTHREAD_MUTEX_INIT                    PTHREAD_MUTEX_INITIALIZER
+#define __GTHREAD_MUTEX_INIT_FUNCTION           __gthread_mutex_init_function
+#define __GTHREAD_RECURSIVE_MUTEX_INIT          PTHREAD_MUTEX_RECURSIVE_INITIALIZER_NP
+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
+#define __GTHREAD_COND_INIT                     PTHREAD_COND_INITIALIZER
+#define __GTHREAD_COND_INIT_FUNCTION            __gthread_cond_init_function
+#define __GTHREAD_TIME_INIT                     {0,0}
+
+#define __gthread_once                    pthread_once
+#define __gthread_mutex_destroy           pthread_mutex_destroy
+#define __gthread_recursive_mutex_destroy pthread_mutex_destroy
+#define __gthread_cond_destroy            pthread_cond_destroy
+#define __gthread_mutex_lock              pthread_mutex_lock
+#define __gthread_mutex_trylock           pthread_mutex_trylock
+#define __gthread_mutex_unlock            pthread_mutex_unlock
+#define __gthread_recursive_mutex_lock    pthread_mutex_lock
+#define __gthread_recursive_mutex_trylock pthread_mutex_trylock
+#define __gthread_recursive_mutex_unlock  pthread_mutex_unlock
+#define __gthread_cond_signal             pthread_cond_signal
+#define __gthread_cond_broadcast          pthread_cond_broadcast
+#define __gthread_cond_wait               pthread_cond_wait
+#define __gthread_cond_wait_recursive     pthread_cond_wait
+#define __gthread_join                    pthread_join
+#define __gthread_detach                  pthread_detach
+#define __gthread_equal                   pthread_equal
+#define __gthread_self                    pthread_self
+#define __gthread_yield                   sched_yield
+
+//These actually aren't implemented in Miosix, so code trying to use these will
+//fail to link, and for now it's the "desired" behaviour (better than failing
+//at runtime, at least). They are used somewhere in libstdc++ too, but it can
+//be patched to remove those uses.
+#define __gthread_key_create                pthread_key_create
+#define __gthread_key_delete                pthread_key_delete
+#define __gthread_getspecific               pthread_getspecific
+#define __gthread_setspecific               pthread_setspecific
+#define __gthread_mutex_timedlock           pthread_mutex_timedlock
+#define __gthread_recursive_mutex_timedlock pthread_mutex_timedlock
+#define __gthread_cond_timedwait            pthread_cond_timedwait
+
+static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex)
+{
+    pthread_mutex_init(__mutex, NULL);
+}
+
+static inline void __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *__mutex)
+{
+    //Defined in newlib patches for Miosix
+    __lock_init_recursive(*__mutex);
+}
+
+static inline void __gthread_cond_init_function(__gthread_cond_t *__cond)
+{
+    pthread_cond_init(__cond, NULL);
+}
+
+static inline int __gthread_create(__gthread_t *__thrd, void *(*__func)(void*), void *__args)
+{
+    return pthread_create(__thrd, NULL, __func, __args);
+}
+
+#endif //GCC_GHTR_MIOSIX_H
diff -ruN gcc-9.2.0-old/libgcc/configure gcc-9.2.0/libgcc/configure
--- gcc-9.2.0-old/libgcc/configure	2018-10-31 18:03:16.000000000 +0100
+++ gcc-9.2.0/libgcc/configure	2020-07-18 19:02:13.489006105 +0200
@@ -5543,6 +5543,7 @@
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
+    miosix)	thread_header=config/gthr-miosix.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
     posix)	thread_header=gthr-posix.h ;;
     rtems)	thread_header=config/gthr-rtems.h ;;
diff -ruN gcc-9.2.0-old/libgcc/unwind-arm-common.inc gcc-9.2.0/libgcc/unwind-arm-common.inc
--- gcc-9.2.0-old/libgcc/unwind-arm-common.inc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libgcc/unwind-arm-common.inc	2020-07-18 19:02:13.489006105 +0200
@@ -46,14 +46,18 @@
     ctm_succeeded_with_ptr_to_base = 2
   };
 
-void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);
-bool __attribute__((weak)) __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);
-enum __cxa_type_match_result __attribute__((weak)) __cxa_type_match
+// Also declaring function prototypes weak seems to trigger the generation of
+// R_ARM_REL32. This only happens with a test program that does not throw
+// exceptions such as a main.cpp with just a printf() compiled without
+// -fno-exceptions for now, we'll just remove weak
+void /*__attribute__((weak))*/ __cxa_call_unexpected(_Unwind_Control_Block *ucbp);
+bool /*__attribute__((weak))*/ __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);
+enum __cxa_type_match_result /*__attribute__((weak))*/ __cxa_type_match
   (_Unwind_Control_Block *ucbp, const type_info *rttip,
    bool is_reference, void **matched_object);
 
-_Unwind_Ptr __attribute__((weak))
-__gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);
+//_Unwind_Ptr __attribute__((weak))
+//__gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);
 
 #define EXIDX_CANTUNWIND 1
 #define uint32_highbit (((_uw) 1) << 31)
@@ -205,7 +209,15 @@
      instruction itself.  */
   return_address -= 2;
 
-  if (__gnu_Unwind_Find_exidx)
+  //TODO: #ifdef _MIOSIX does not work in this context
+  /*
+   * Apparently checking the address of a weak symbol does not work in Miosix
+   * processes, as we get
+   * libgcc.a(unwind-arm.o): relocation R_ARM_REL32 against external or undefined symbol `__gnu_Unwind_Find_exidx' can not be used when making a PIE executable; recompile with -fPIC
+   * unwind-arm-common.inc:237:(.text+0x138): dangerous relocation: unsupported relocation
+   * Since in Miosix we have __exidx_start|end, just remove this code
+   */
+  /*if (__gnu_Unwind_Find_exidx)
     {
       eitp = (const __EIT_entry *) __gnu_Unwind_Find_exidx (return_address,
 							    &nrec);
@@ -216,10 +228,10 @@
 	}
     }
   else
-    {
+    {*/
       eitp = &__exidx_start;
       nrec = &__exidx_end - &__exidx_start;
-    }
+    //}
 
   eitp = search_EIT_table (eitp, nrec, return_address);
 
diff -ruN gcc-9.2.0-old/libgcc/unwind-sjlj.c gcc-9.2.0/libgcc/unwind-sjlj.c
--- gcc-9.2.0-old/libgcc/unwind-sjlj.c	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libgcc/unwind-sjlj.c	2020-07-18 19:02:13.489006105 +0200
@@ -91,7 +91,14 @@
   _Unwind_Personality_Fn personality;
 } _Unwind_FrameState;
 
-
+
+// RATIONALE: _Miosix_set_sjlj_ptr and _Miosix_get_sjlj_ptr make
+// exception handling thread-safe even if Miosix does not support TLS
+// NOTE: C++ uses exception support is in eh_globals.cc, is there any code that
+// triggers these to be called? Otherwise we may either keep them if Miosix
+// will support architectures with sjlj exceptions, or even remove this patch
+#ifndef _MIOSIX
+
 /* Manage the chain of registered function contexts.  */
 
 /* Single threaded fallback chain.  */
@@ -163,6 +170,32 @@
     fc_static = fc;
 }
 
+#else //_MIOSIX
+
+void _Miosix_set_sjlj_ptr(void* ptr);
+void *_Miosix_get_sjlj_ptr();
+
+void
+_Unwind_SjLj_Register (struct SjLj_Function_Context *fc)
+{
+  fc->prev=_Miosix_get_sjlj_ptr();
+  _Miosix_set_sjlj_ptr(fc);
+}
+
+static inline struct SjLj_Function_Context *
+_Unwind_SjLj_GetContext (void)
+{
+  return _Miosix_get_sjlj_ptr();
+}
+
+static inline void
+_Unwind_SjLj_SetContext (struct SjLj_Function_Context *fc)
+{
+  _Miosix_set_sjlj_ptr(fc);
+}
+
+#endif //_MIOSIX
+
 void
 _Unwind_SjLj_Unregister (struct SjLj_Function_Context *fc)
 {
diff -ruN gcc-9.2.0-old/libstdc++-v3/configure gcc-9.2.0/libstdc++-v3/configure
--- gcc-9.2.0-old/libstdc++-v3/configure	2019-07-03 23:09:13.000000000 +0200
+++ gcc-9.2.0/libstdc++-v3/configure	2020-07-18 19:02:13.505006083 +0200
@@ -15419,6 +15419,7 @@
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
+    miosix)	thread_header=config/gthr-miosix.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
     posix)	thread_header=gthr-posix.h ;;
     rtems)	thread_header=config/gthr-rtems.h ;;
@@ -20886,6 +20887,23 @@
         ac_has_nanosleep=yes
         ac_has_sched_yield=yes
         ;;
+    esac
+
+    # apparently the miosix in arm-miosix-eabi is ${target_vendor}
+    case "${target_vendor}" in
+        miosix*)
+        # Rationale: src/c++11/chrono.cc src/c++11/thread.cc include/std/thread
+        # need to target the best syscalls for querying the time and sleeping,
+        # which are
+        # clock_gettime(CLOCK_REALTIME, &tp);  //starting Jan 1st, 1970
+        # clock_gettime(CLOCK_MONOTONIC, &tp); //starting @ boot
+        # clock_nanosleep(CLOCK_MONOTONIC, 0, &__ts, &__ts);
+        # clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &__ts, &__ts);
+        ac_has_clock_realtime=yes
+        ac_has_clock_monotonic=yes
+        ac_has_nanosleep=yes
+        ac_has_sched_yield=yes
+        ;;
     esac
 
   elif test x"$enable_libstdcxx_time" != x"no"; then
diff -ruN gcc-9.2.0-old/libstdc++-v3/include/bits/basic_string.h gcc-9.2.0/libstdc++-v3/include/bits/basic_string.h
--- gcc-9.2.0-old/libstdc++-v3/include/bits/basic_string.h	2019-04-24 17:17:53.000000000 +0200
+++ gcc-9.2.0/libstdc++-v3/include/bits/basic_string.h	2020-07-18 19:02:13.505006083 +0200
@@ -6538,43 +6538,81 @@
   { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
 #endif // _GLIBCXX_USE_C99_STDLIB
 
+//
+// Patch rationale: use newlib-specific version of vsnprintf to save code size
+//
+
 #if _GLIBCXX_USE_C99_STDIO
   // NB: (v)snprintf vs sprintf.
 
   // DR 1261.
   inline string
   to_string(int __val)
+#ifndef _MIOSIX
   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
 					   "%d", __val); }
+#else
+  { return __gnu_cxx::__to_xstring<string>(&vsniprintf, 4 * sizeof(int),
+					   "%d", __val); }
+#endif
 
   inline string
   to_string(unsigned __val)
+#ifndef _MIOSIX
   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
 					   4 * sizeof(unsigned),
 					   "%u", __val); }
+#else
+  { return __gnu_cxx::__to_xstring<string>(&vsniprintf,
+					   4 * sizeof(unsigned),
+					   "%u", __val); }
+#endif
 
   inline string
   to_string(long __val)
+#ifndef _MIOSIX
   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
 					   "%ld", __val); }
+#else
+  { return __gnu_cxx::__to_xstring<string>(&vsniprintf, 4 * sizeof(long),
+					   "%ld", __val); }
+#endif
 
   inline string
   to_string(unsigned long __val)
+#ifndef _MIOSIX
   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
 					   4 * sizeof(unsigned long),
 					   "%lu", __val); }
+#else
+  { return __gnu_cxx::__to_xstring<string>(&vsniprintf,
+					   4 * sizeof(unsigned long),
+					   "%lu", __val); }
+#endif
 
   inline string
   to_string(long long __val)
+#ifndef _MIOSIX
   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
 					   4 * sizeof(long long),
 					   "%lld", __val); }
+#else
+  { return __gnu_cxx::__to_xstring<string>(&vsniprintf,
+					   4 * sizeof(long long),
+					   "%lld", __val); }
+#endif
 
   inline string
   to_string(unsigned long long __val)
+#ifndef _MIOSIX
   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
 					   4 * sizeof(unsigned long long),
 					   "%llu", __val); }
+#else
+  { return __gnu_cxx::__to_xstring<string>(&vsniprintf,
+					   4 * sizeof(unsigned long long),
+					   "%llu", __val); }
+#endif
 
   inline string
   to_string(float __val)
diff -ruN gcc-9.2.0-old/libstdc++-v3/include/bits/basic_string.tcc gcc-9.2.0/libstdc++-v3/include/bits/basic_string.tcc
--- gcc-9.2.0-old/libstdc++-v3/include/bits/basic_string.tcc	2019-01-05 00:23:22.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/include/bits/basic_string.tcc	2020-07-18 19:02:13.505006083 +0200
@@ -1596,6 +1596,15 @@
       return __in;
     }
 
+/*
+ * Disabling instantiation of std::string from user code forces the use of
+ * the instantiation in string-inst.cc which may reduce compile
+ * times but it hardcodes that C++ exceptions are enabled causing code bloat, as
+ * arm-miosix-eabi-objdump -t string-inst.o | grep '\*UND\*.*__cxa'
+ * shows.
+ */
+#ifndef _MIOSIX
+    
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
@@ -1649,6 +1658,8 @@
 #endif // _GLIBCXX_USE_WCHAR_T
 #endif // _GLIBCXX_EXTERN_TEMPLATE
 
+#endif //_MIOSIX
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/include/bits/fstream.tcc gcc-9.2.0/libstdc++-v3/include/bits/fstream.tcc
--- gcc-9.2.0-old/libstdc++-v3/include/bits/fstream.tcc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/include/bits/fstream.tcc	2020-07-18 19:02:13.505006083 +0200
@@ -80,7 +80,12 @@
     basic_filebuf<_CharT, _Traits>::
     basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
     _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
-    _M_state_last(), _M_buf(0), _M_buf_size(BUFSIZ),
+    _M_state_last(), _M_buf(0),
+#ifndef _MIOSIX
+    _M_buf_size(BUFSIZ),
+#else
+    _M_buf_size(BUFSIZ+1), //By TFT: BUFSIZ+1 to optimize reads/writes
+#endif
     _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(), 
     _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
     _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
diff -ruN gcc-9.2.0-old/libstdc++-v3/include/std/condition_variable gcc-9.2.0/libstdc++-v3/include/std/condition_variable
--- gcc-9.2.0-old/libstdc++-v3/include/std/condition_variable	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/include/std/condition_variable	2020-07-18 19:02:13.505006083 +0200
@@ -78,12 +78,32 @@
   public:
     typedef __native_type* 		native_handle_type;
 
+/*
+ * This patch works together with the one in src/c++11/condition_variable.cc
+ */
+#ifndef _MIOSIX
+    
     condition_variable() noexcept;
     ~condition_variable() noexcept;
+    
+#else //_MIOSIX
+    
+    #ifndef __GTHREAD_COND_INIT
+    #error shouldn't fail
+    #endif
+    // __GTHREAD_COND_INIT is defined in Miosix, nothing to do
+    condition_variable() noexcept = default;
+    // pthread_cond_destroy isn't needed in Miosix, and even the original
+    // libstdc++ code doesnt't handle EBUSY anyway
+    ~condition_variable() noexcept = default;
+    
+#endif //_MIOSIX
 
     condition_variable(const condition_variable&) = delete;
     condition_variable& operator=(const condition_variable&) = delete;
 
+#ifndef _MIOSIX
+    
     void
     notify_one() noexcept;
 
@@ -92,6 +112,31 @@
 
     void
     wait(unique_lock<mutex>& __lock) noexcept;
+    
+#else //_MIOSIX
+    
+    void
+    notify_one() noexcept
+    {
+      int __e = __gthread_cond_signal(&_M_cond);
+      if (__e) __throw_system_error(__e);
+    }
+
+    void
+    notify_all() noexcept
+    {
+      int __e = __gthread_cond_broadcast(&_M_cond);
+      if (__e) __throw_system_error(__e);
+    }
+
+    void
+    wait(unique_lock<mutex>& __lock) noexcept
+    {
+      int __e = __gthread_cond_wait(&_M_cond, __lock.mutex()->native_handle());
+      if (__e) std::terminate();
+    }
+    
+#endif //_MIOSIX
 
     template<typename _Predicate>
       void
diff -ruN gcc-9.2.0-old/libstdc++-v3/include/std/thread gcc-9.2.0/libstdc++-v3/include/std/thread
--- gcc-9.2.0-old/libstdc++-v3/include/std/thread	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/include/std/thread	2020-07-18 19:02:13.565006005 +0200
@@ -50,6 +50,11 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  // Patch rationale: _M_start_thread needs this
+#ifdef _MIOSIX
+  extern "C" void* execute_native_thread_routine(void* __p);
+#endif
+
   /**
    * @defgroup threads Threads
    * @ingroup concurrency
@@ -83,6 +88,11 @@
 
       explicit
       id(native_handle_type __id) : _M_thread(__id) { }
+      
+      // Patch rationale: join() and detach() patches need this
+#ifdef _MIOSIX
+      native_handle_type _M_get() const noexcept { return _M_thread; }
+#endif
 
     private:
       friend class thread;
@@ -162,11 +172,42 @@
     joinable() const noexcept
     { return !(_M_id == id()); }
 
+#ifndef _MIOSIX
     void
     join();
 
     void
     detach();
+#else
+    //Patch rationale: compiling these in libstdc++.a pulls in exceptions
+    void
+    join()
+    {
+      int __e = EINVAL;
+
+      if (_M_id._M_get() != id()._M_get())
+        __e = __gthread_join(_M_id._M_thread, 0);
+
+      if (__e)
+        __throw_system_error(__e);
+
+      _M_id = id();
+    }
+
+    void
+    detach()
+    {
+      int __e = EINVAL;
+
+      if (_M_id._M_get() != id()._M_get())
+        __e = __gthread_detach(_M_id._M_thread);
+
+      if (__e)
+        __throw_system_error(__e);
+
+      _M_id = id();
+  }
+#endif
 
     thread::id
     get_id() const noexcept
@@ -195,8 +236,22 @@
 	_M_run() { _M_func(); }
       };
 
+#ifndef _MIOSIX
     void
     _M_start_thread(_State_ptr, void (*)());
+#else
+    //Patch rationale: compiling this in libstdc++.a pulls in exceptions
+    void
+    _M_start_thread(_State_ptr state, void (*)())
+    {
+      const int err = __gthread_create(&_M_id._M_thread,
+				       &execute_native_thread_routine,
+				       state.get());
+      if (err)
+        __throw_system_error(err);
+      state.release();
+    }
+#endif
 
     template<typename _Callable>
       static _State_ptr
@@ -375,8 +430,14 @@
 	    static_cast<std::time_t>(__s.count()),
 	    static_cast<long>(__ns.count())
 	  };
+	  //Patch rationale: use Miosix preferred sleep function
+#ifdef _MIOSIX
+	while (::clock_nanosleep(CLOCK_MONOTONIC, 0, &__ts, &__ts) == -1 && errno == EINTR)
+	  { }
+#else //_MIOISX
 	while (::nanosleep(&__ts, &__ts) == -1 && errno == EINTR)
 	  { }
+#endif //_MIOSIX
 #else
 	__sleep_for(__s, __ns);
 #endif
@@ -387,6 +448,20 @@
       inline void
       sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)
       {
+	  //Patch rationale: do not add skew by converting absolute sleep to relative
+#ifdef _MIOSIX
+	auto __rtime = __atime.time_since_epoch();
+	auto __s = chrono::duration_cast<chrono::seconds>(__rtime);
+	auto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);
+	__gthread_time_t __ts =
+	  {
+	    static_cast<std::time_t>(__s.count()),
+	    static_cast<long>(__ns.count())
+	  };
+	clockid_t __clk = _Clock::is_steady ? CLOCK_MONOTONIC : CLOCK_REALTIME;
+	while (::clock_nanosleep(__clk, TIMER_ABSTIME, &__ts, &__ts) == -1 && errno == EINTR)
+	  { }
+#else //_MIOSIX
 	auto __now = _Clock::now();
 	if (_Clock::is_steady)
 	  {
@@ -399,6 +474,7 @@
 	    sleep_for(__atime - __now);
 	    __now = _Clock::now();
 	  }
+#endif //_MIOSIX
       }
   }
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/bad_array_length.cc gcc-9.2.0/libstdc++-v3/libsupc++/bad_array_length.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/bad_array_length.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/bad_array_length.cc	2020-07-18 19:02:13.565006005 +0200
@@ -48,9 +48,18 @@
 
 } // namespace std
 
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 namespace __cxxabiv1 {
 
-extern "C" void
+extern "C" void AW
 __cxa_throw_bad_array_length ()
 { _GLIBCXX_THROW_OR_ABORT(std::bad_array_length()); }
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_alloc.cc gcc-9.2.0/libstdc++-v3/libsupc++/eh_alloc.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_alloc.cc	2019-01-21 12:47:30.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/eh_alloc.cc	2020-07-18 19:02:13.565006005 +0200
@@ -73,6 +73,14 @@
 # define EMERGENCY_OBJ_COUNT	4
 #endif
 
+//RATIONALE: reduced emergency buffer for ARM microcontrollers, saves RAM
+#ifdef _MIOSIX
+# undef EMERGENCY_OBJ_SIZE
+# undef EMERGENCY_OBJ_COUNT
+# define EMERGENCY_OBJ_SIZE  160
+# define EMERGENCY_OBJ_COUNT 3
+#endif
+
 namespace __gnu_cxx
 {
   void __freeres();
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_aux_runtime.cc gcc-9.2.0/libstdc++-v3/libsupc++/eh_aux_runtime.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_aux_runtime.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/eh_aux_runtime.cc	2020-07-18 19:02:13.565006005 +0200
@@ -29,14 +29,23 @@
 #include "unwind-cxx.h"
 #include <bits/exception_defines.h>
 
-extern "C" void
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
+extern "C" void AW
 __cxxabiv1::__cxa_bad_cast ()
 { _GLIBCXX_THROW_OR_ABORT(std::bad_cast()); }
 
-extern "C" void
+extern "C" void AW
 __cxxabiv1::__cxa_bad_typeid ()
 { _GLIBCXX_THROW_OR_ABORT(std::bad_typeid()); }
 
-extern "C" void
+extern "C" void AW
 __cxxabiv1::__cxa_throw_bad_array_new_length ()
 { _GLIBCXX_THROW_OR_ABORT(std::bad_array_new_length()); }
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_globals.cc gcc-9.2.0/libstdc++-v3/libsupc++/eh_globals.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_globals.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/eh_globals.cc	2020-07-18 19:02:13.569005999 +0200
@@ -41,6 +41,11 @@
 
 using namespace __cxxabiv1;
 
+// RATIONALE: __cxa_get_globals() and __cxa_get_globals_fast() have been made
+// Miosix syscalls since the __cxa_eh_globals struct needs to be provided on
+// a per-thread basis but Miosix does not support TLS
+#ifndef _MIOSIX
+
 #if _GLIBCXX_HAVE_TLS
 
 namespace
@@ -157,3 +162,5 @@
 #endif
 
 #endif
+
+#endif //_MIOSIX
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_terminate.cc gcc-9.2.0/libstdc++-v3/libsupc++/eh_terminate.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/eh_terminate.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/eh_terminate.cc	2020-07-18 19:02:13.569005999 +0200
@@ -37,6 +37,15 @@
 }
 #endif
 
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 using namespace __cxxabiv1;
 
 void
@@ -51,7 +60,7 @@
     { std::abort (); }
 }
 
-void
+void AW
 std::terminate () throw()
 {
   __terminate (get_terminate ());
@@ -64,7 +73,7 @@
   std::terminate ();
 }
 
-void
+void AW
 std::unexpected ()
 {
   __unexpected (get_unexpected ());
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/guard.cc gcc-9.2.0/libstdc++-v3/libsupc++/guard.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/guard.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/guard.cc	2020-07-18 19:02:13.569005999 +0200
@@ -190,6 +190,11 @@
 //  | _GLIBCXX_GUARD_WAITING_BIT) and some other threads are waiting until
 //				  it is initialized.
 
+// RATIONALE: __cxa_guard_[acquire|release|abort] have been made Miosix syscalls
+// as static object initialization can occur also before the kernel is started,
+// therefore at a time when using pthread_mutexe and pthread_cond is unsafe.
+#ifndef _MIOSIX
+
 namespace __cxxabiv1 
 {
 #ifdef _GLIBCXX_USE_FUTEX
@@ -425,3 +430,5 @@
 #endif
   }
 }
+
+#endif //_MIOSIX
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/pure.cc gcc-9.2.0/libstdc++-v3/libsupc++/pure.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/pure.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/pure.cc	2020-07-18 19:02:13.569005999 +0200
@@ -43,14 +43,23 @@
 # define writestr(str) /* Empty */
 #endif
 
-extern "C" void
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
+extern "C" void AW
 __cxxabiv1::__cxa_pure_virtual (void)
 {
   writestr ("pure virtual method called\n");
   std::terminate ();
 }
 
-extern "C" void
+extern "C" void AW
 __cxxabiv1::__cxa_deleted_virtual (void)
 {
   writestr ("deleted virtual method called\n");
diff -ruN gcc-9.2.0-old/libstdc++-v3/libsupc++/vterminate.cc gcc-9.2.0/libstdc++-v3/libsupc++/vterminate.cc
--- gcc-9.2.0-old/libstdc++-v3/libsupc++/vterminate.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/libsupc++/vterminate.cc	2020-07-18 19:02:13.569005999 +0200
@@ -31,13 +31,33 @@
 #include <cxxabi.h>
 # include <cstdio>
 
+#include <unistd.h>
+
 using namespace std;
 using namespace abi;
 
+// RATIONALE: add __attribute__((weak)) to make __verbose_terminate_handler
+// overridable to save the code size of __cxa_demangle
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 namespace __gnu_cxx
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  // XXX: having trouble overriding weak functions in Miosix processes,
+  // and this function is increasing code size significantly, replacing it
+  void AW __verbose_terminate_handler()
+  {
+      write(1,"terminate called\n",17);
+      _exit(1);
+  }
+  
+#if 0
+
   // A replacement for the standard terminate_handler which prints
   // more information about the terminating exception (if any) on
   // stderr.
@@ -95,6 +115,8 @@
     abort();
   }
 
+#endif
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/src/c++11/condition_variable.cc gcc-9.2.0/libstdc++-v3/src/c++11/condition_variable.cc
--- gcc-9.2.0-old/libstdc++-v3/src/c++11/condition_variable.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/src/c++11/condition_variable.cc	2020-07-18 19:02:13.569005999 +0200
@@ -31,6 +31,16 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+/*
+ * Patch rationale: this file is compiled when libstdc++ is built, with
+ * exceptions enabled. When Miosix is compiled with exceptions disabled and
+ * these are used, they cause some of the exception support to be pulled in
+ * increasing code size. These are also so simple that inlining them will
+ * make condition_variable faster. A win-win.
+ * This patch works together with the one in include/std/condition_variable
+ */
+#ifndef _MIOSIX
+
 #ifdef __GTHREAD_COND_INIT
   condition_variable::condition_variable() noexcept = default;
 #else
@@ -78,6 +88,8 @@
       __throw_system_error(__e);
   }
 
+#endif //_MIOSIX
+
   extern void
   __at_thread_exit(__at_thread_exit_elt*);
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/src/c++11/functexcept.cc gcc-9.2.0/libstdc++-v3/src/c++11/functexcept.cc
--- gcc-9.2.0-old/libstdc++-v3/src/c++11/functexcept.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/src/c++11/functexcept.cc	2020-07-18 19:02:13.569005999 +0200
@@ -35,6 +35,15 @@
 # define _(msgid)   (msgid)
 #endif
 
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 namespace __gnu_cxx
 {
   int __snprintf_lite(char *__buf, size_t __bufsize, const char *__fmt,
@@ -45,45 +54,46 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
+  void AW
   __throw_bad_exception()
   { _GLIBCXX_THROW_OR_ABORT(bad_exception()); }
 
-  void
+  void AW
   __throw_bad_alloc()
   { _GLIBCXX_THROW_OR_ABORT(bad_alloc()); }
 
-  void
+  void AW
   __throw_bad_cast()
   { _GLIBCXX_THROW_OR_ABORT(bad_cast()); }
 
-  void
+  void AW
   __throw_bad_typeid()
   { _GLIBCXX_THROW_OR_ABORT(bad_typeid()); }
 
-  void
+  void AW
   __throw_logic_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(logic_error(_(__s))); }
 
-  void
+  void AW
   __throw_domain_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(domain_error(_(__s))); }
 
-  void
+  void AW
   __throw_invalid_argument(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(invalid_argument(_(__s))); }
 
-  void
+  void AW
   __throw_length_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(length_error(_(__s))); }
 
-  void
+  void AW
   __throw_out_of_range(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(out_of_range(_(__s))); }
 
-  void
+  void AW
   __throw_out_of_range_fmt(const char* __fmt, ...)
   {
+    #ifndef _MIOSIX
     const size_t __len = __builtin_strlen(__fmt);
     // We expect at most 2 numbers, and 1 short string. The additional
     // 512 bytes should provide more than enough space for expansion.
@@ -95,21 +105,31 @@
     __gnu_cxx::__snprintf_lite(__s, __alloca_size, __fmt, __ap);
     _GLIBCXX_THROW_OR_ABORT(out_of_range(_(__s)));
     va_end(__ap);  // Not reached.
+    #else
+    // Miosix applications usually run with tiny stacks of a few KB, doing an
+    // alloca of 512+ bytes is almost guaranteed to cause stack overflow.
+    // The fact that this allocation happens if an exception is thrown (which
+    // should normally not occur) only makes testing and sizing stacks harder.
+    // For this reason, even if it is a nice feature, we've decided to not
+    // expand formats. Users will get a strange exception with %zu or other
+    // format strings in it, but at least no stack overflow.
+    _GLIBCXX_THROW_OR_ABORT(out_of_range(_(__fmt)));
+    #endif
   }
 
-  void
+  void AW
   __throw_runtime_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(runtime_error(_(__s))); }
 
-  void
+  void AW
   __throw_range_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(range_error(_(__s))); }
 
-  void
+  void AW
   __throw_overflow_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(overflow_error(_(__s))); }
 
-  void
+  void AW
   __throw_underflow_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(underflow_error(_(__s))); }
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/src/c++11/functional.cc gcc-9.2.0/libstdc++-v3/src/c++11/functional.cc
--- gcc-9.2.0-old/libstdc++-v3/src/c++11/functional.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/src/c++11/functional.cc	2020-07-18 19:02:13.569005999 +0200
@@ -25,11 +25,20 @@
 #include <functional>
 #include <bits/functexcept.h>
 
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
+  void AW
   __throw_bad_function_call()
   { _GLIBCXX_THROW_OR_ABORT(bad_function_call()); }
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/src/c++11/future.cc gcc-9.2.0/libstdc++-v3/src/c++11/future.cc
--- gcc-9.2.0-old/libstdc++-v3/src/c++11/future.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/src/c++11/future.cc	2020-07-18 19:02:13.569005999 +0200
@@ -25,6 +25,15 @@
 #include <future>
 #include <bits/functexcept.h>
 
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 namespace
 {
   struct future_error_category : public std::error_category
@@ -71,7 +80,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
+  void AW
   __throw_future_error(int __i __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
 
diff -ruN gcc-9.2.0-old/libstdc++-v3/src/c++11/system_error.cc gcc-9.2.0/libstdc++-v3/src/c++11/system_error.cc
--- gcc-9.2.0-old/libstdc++-v3/src/c++11/system_error.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/src/c++11/system_error.cc	2020-07-18 19:02:13.573005993 +0200
@@ -32,6 +32,15 @@
 #include <errno.h>
 #undef __sso_string
 
+// RATIONALE: adding __attribute__((weak)) to these functions allows redefining
+// them if compiling without exceptions to avoid pulling in exception support
+// and save code size
+#ifdef _MIOSIX
+#define AW __attribute__((weak))
+#else
+#define AW
+#endif
+
 namespace
 {
   using std::string;
@@ -331,7 +340,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
+  void AW
   __throw_system_error(int __i __attribute__((unused)))
   {
     _GLIBCXX_THROW_OR_ABORT(system_error(error_code(__i, generic_category())));
diff -ruN gcc-9.2.0-old/libstdc++-v3/src/c++11/thread.cc gcc-9.2.0/libstdc++-v3/src/c++11/thread.cc
--- gcc-9.2.0-old/libstdc++-v3/src/c++11/thread.cc	2019-01-01 13:31:55.000000000 +0100
+++ gcc-9.2.0/libstdc++-v3/src/c++11/thread.cc	2020-07-18 19:02:13.573005993 +0200
@@ -22,8 +22,12 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-
+// Patch rationale: don't need to be ABI backwards compatible, and
+// on top of that the compat code pulls in exceptions when compiling Miosix with
+// exceptions disabled.
+#ifndef _MIOSIX
 #define _GLIBCXX_THREAD_ABI_COMPAT 1
+#endif //_MIOSIX
 #include <thread>
 #include <system_error>
 #include <cerrno>
@@ -73,7 +77,16 @@
 {
   extern "C"
   {
+    /*
+     * Patch rationale: the need to call the class destructor makes it
+     * call __cxa_end_cleanup which pulls in exception code. Thus, reimplemented
+     * in Miosix when compiling without exceptions.
+     */
+#ifdef _MIOSIX
+    void* __attribute__((weak))
+#else
     static void*
+#endif
     execute_native_thread_routine(void* __p)
     {
       thread::_State_ptr __t{ static_cast<thread::_State*>(__p) };
@@ -101,6 +114,9 @@
 
   thread::_State::~_State() = default;
 
+  //Patch rationale: compiling these in libstdc++.a pulls in exceptions
+  //This patch works together with the one in include/std/thread
+#ifndef _MIOSIX
   void
   thread::join()
   {
@@ -139,6 +155,7 @@
       __throw_system_error(err);
     state.release();
   }
+#endif
 
 #if _GLIBCXX_THREAD_ABI_COMPAT
   void
